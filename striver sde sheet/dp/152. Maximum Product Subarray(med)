problem:https://leetcode.com/problems/maximum-product-subarray/
video:
/*
brute force(GETTING TLE)
time:O(n^3)
space:O(1)
*/


/*ALGORITHM
1.take ans varible initialize with INT_MIN
2.take first index cal maxproduct for subarrays of size 1,2,3... at the same time when u make subarray of each size just update the ans variable..similary repeat for other indices too
3.here i represents start index of our subarray
4.j represents end point of our subarray 
5.k represents the curr index we are calculating prod for
6.return ans
*/

#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int maxProduct(vector<int>& nums) {
    int ans=INT_MIN;
        int pro;
        for(int i=0;i<nums.size();i++){
            for(int j=i;j<nums.size();j++){
                 pro=1;
               for(int k=i;k<=j;k++){
               

                    pro=pro*nums[k];
                    
               }
                ans=max(ans,pro);
            }
        }
        return ans;
    }
};

/*
OTIMISED CODE
tc:O(n)
sc:O(1)
video exlaination:https://youtu.be/vtJvbRlHqTA
pseudo code:what we are doing here is that each time we are moving forward we are 
carrying with us the max so far as well as the min so far then at every moment we calculate current max  
...it may be possible that our past value has reduced to zero so at the current index we will start from that index...
then after calculating curr max we are updating  ans,maxSoFar and minSoFar
*/
int maxProduct(vector<int>& a) {
        int n=a.size();
         int ans=a[0];
	    int curr=a[0];
	    int  minSoFar=a[0];
	   int maxSoFar=a[0];
	    for(int i=1;i<n;i++){
	        curr=max(maxSoFar*a[i],max(minSoFar*a[i],a[i]));
	        ans=max(ans,curr);
	         minSoFar=min(maxSoFar*a[i],min(minSoFar*a[i],a[i]));
	         maxSoFar=curr;
	    }
	   
	    return ans;

